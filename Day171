import numpy as np
targetAreaX = np.arange(240, 293)
targetAreaY = np.arange(-90, -56)

MAX_ITERATIONS = 1000

def shot(x, y, dx, dy):
    """ Yields the resulting shot positions for the first 1000 iterations """
    j = 0
    while j < MAX_ITERATIONS:
        yield x + dx, y + dy
        x += dx
        y += dy
        if dx > 0: dx -= 1
        if dx < 0: dx += 1
        dy -= 1
        j += 1

# First Approach: exhaustive search
maxHeights = [] # List of maximun heights for valid shots

i = 0

# For each considered initial velocity,  
for initDx in range(21, 24):  
    for initDy in range(0, MAX_ITERATIONS // 2):
        #if not i % 10: print(i)

        # Compute the resulting shot until we exactly know 
        # it won't reach the ocean trench (y < targetArea y's)
        
        maxHeight = targetAreaY[0]
        for x, y in shot(0, 0, initDx, initDy):
            if maxHeight < y: maxHeight = y
            if x in targetAreaX and y in targetAreaY:
                maxHeights.append((maxHeight, initDx, initDy))
                break
    
print("The maximizing height is:", max(maxHeights, key = lambda x: x[0]))

# I want to compute the initial x velocities that make the prove to be in the xArea (no y considered)
initialVelocitiesX = set()

for initDx in range(0, targetAreaX[-1] + 1):
    for x, _ in shot(0, 0, initDx, 0):
        if x in targetAreaX: initialVelocitiesX.add(initDx)

print("Different x velocity component possible initial values:", len(initialVelocitiesX))

# Now the same with y velocities: compute how many y velocity components match the requirements for each matching x component
initialVelocities = set()

for initDx in initialVelocitiesX:
    for initDy in range(targetAreaY[0], 89 + 1): # 89 is the maximizing Y component, from the first Part

        for x, y in shot(0, 0, initDx, initDy):
            #if y < targetAreaY[0]: break

            if x in targetAreaX and y in targetAreaY:
                initialVelocities.add((initDx, initDy))
                #break

len(initialVelocities)